function sysCall_init()
    corout=coroutine.create(coroutineMain)
    a=2 -- this is for compute working space
    
    -- initialize the dummy point for IK
    local tipHandle = sim.createDummy(0.01)
    local targetHandle = sim.createDummy(0.01)
    -- dummy point rename
    sim.setObjectAlias(tipHandle, "tip")
    sim.setObjectAlias(targetHandle, "target")
    -- set the dummy point position
    simBase=sim.getObject('.')
    objectHandlesall = sim.getObjectsInTree(simBase,sim.handle_all,0)
    --print(sim.getObjectAlias(objectHandlesall[#objectHandlesall],-1))
    -- endEffector is not a idel position, modify it later
    endEffectorpos = sim.getObjectPosition(objectHandlesall[#objectHandlesall], sim.handle_world)
    sim.setObjectPosition(tipHandle, sim.handle_world, endEffectorpos)
    sim.setObjectPosition(targetHandle, sim.handle_world, endEffectorpos)
    -- set dummy point to the parent object
    sim.setObjectParent(tipHandle,objectHandlesall[#objectHandlesall],true)
    sim.setObjectParent(targetHandle,simBase,true)
    
    
    -- get joint Handles
    jointHandles = sim.getObjectsInTree(simBase,sim.object_joint_type,0)
    
    -- prepare handles for the IK calculation
    simBase=sim.getObject('.')
    simTip=sim.getObject('./tip')
    simTarget=sim.getObject('./target')
    
    simJoints=jointHandles
    -- Prepare an ik group, using the convenience function 'simIK.addIkElementFromScene':
    ikEnv=simIK.createEnvironment()
    ikGroup=simIK.createIkGroup(ikEnv)
    -- simIK.method_damped_least_squares better 2
    -- simIK.method_undamped_pseudo_inverse terrible 4
    -- simIK.method_jacobian_transpose best  1
    -- simIK.method_pseudo_inverse middle 3
    simIK.setIkGroupCalculation(ikEnv,ikGroup,simIK.method_jacobian_transpose,0.05,180)
    local ikElement=simIK.addIkElementFromScene(ikEnv,ikGroup,simBase,simTip,simTarget,simIK.constraint_pose)
    simIK.setIkElementPrecision(ikEnv,ikGroup,ikElement,{0.0005,0.001*math.pi/180})
    
    
    
    -- set basic parameters for vel, accel, jerk for the moveTojoint
    local vel=180
    local accel=40
    local jerk=80
    default_maxVel={vel*math.pi/180,vel*math.pi/180,vel*math.pi/180,vel*math.pi/180,vel*math.pi/180,vel*math.pi/180}
    default_maxAccel={accel*math.pi/180,accel*math.pi/180,accel*math.pi/180,accel*math.pi/180,accel*math.pi/180,accel*math.pi/180}
    default_maxJerk={jerk*math.pi/180,jerk*math.pi/180,jerk*math.pi/180,jerk*math.pi/180,jerk*math.pi/180,jerk*math.pi/180}
    
    maxVel={}
    maxAccel={}
    maxJerk={}
    initialJointPositions={} -- also record the inital joint position
    for i=1,#jointHandles,1 do
        maxVel[i]=default_maxVel[i]
        maxAccel[i]=default_maxAccel[i]
        maxJerk[i]=default_maxJerk[i]
        initialJointPositions[i]=sim.getJointPosition(jointHandles[i])
    end
    
end

function sysCall_actuation()
    if coroutine.status(corout)~='dead' then
        local ok,errorMsg=coroutine.resume(corout)
        if errorMsg then
            error(debug.traceback(corout,errorMsg),2)
        end
    end
end

-- This is a threaded script, and is just an example!
function moveToPoseCallback(pose,velocity,accel,auxData)
    sim.setObjectPose(auxData.target,sim.handle_world,pose)
    simIK.applyIkEnvironmentToScene(auxData.ikEnv,auxData.ikGroup)
end

function moveToPose_viaIK(maxVelocity,maxAcceleration,maxJerk,targetPose,auxData)
    local currentPose=sim.getObjectPose(auxData.tip,sim.handle_world)
    return sim.moveToPose(-1,currentPose,maxVelocity,maxAcceleration,maxJerk,targetPose,moveToPoseCallback,auxData,nil)
end

function movCallback(config,vel,accel,handles)
    for i=1,#handles,1 do
        if sim.isDynamicallyEnabled(handles[i]) then
            sim.setJointTargetPosition(handles[i],config[i])
        else    
            sim.setJointPosition(handles[i],config[i])
        end
    end
end

function moveToConfig(handles,maxVel,maxAccel,maxJerk,targetConf)
    local currentConf={}
    for i=1,#handles,1 do
        currentConf[i]=sim.getJointPosition(handles[i])
    end
    sim.moveToConfig(-1,currentConf,nil,nil,maxVel,maxAccel,maxJerk,targetConf,nil,movCallback,handles)
end

function moveTojoint(position)
    moveToConfig(jointHandles,maxVel,maxAccel,maxJerk,position)
end

function getJointposition()
    local curJointpos={}
    for i=1,#jointHandles,1 do
        curJointpos[i]=sim.getJointPosition(jointHandles[i])
    end
    
    return curJointpos
end

function moveToinitialPosition()
    moveTojoint(initialJointPositions)
end

function moveToPosition(targetPosition)
    -- convert the targetPosition to targetPose
    local targetDummy = sim.createDummy(0.01)
    sim.setObjectPosition(targetDummy,sim.getObject('.'), targetPosition)
    
    local targetPose = sim.getObjectPose(targetDummy,sim.handle_world)
    sim.removeObject(targetDummy)

    -- IK movement data:
    local maxIkVel={0.45,0.45,0.45,4.5} -- vx,vy,vz in m/s, Vtheta is rad/s
    local maxIkAccel={0.13,0.13,0.13,1.24} -- ax,ay,az in m/s^2, Atheta is rad/s^2
    local maxIkJerk={0.1,0.1,0.1,0.2} -- is ignored (i.e. infinite) with RML type 2
    
    local data={}
    data.ikEnv=ikEnv
    data.ikGroup=ikGroup
    data.tip=simTip
    data.target=simTarget
    data.joints=simJoints

    moveToPose_viaIK(maxIkVel,maxIkAccel,maxIkJerk,targetPose,data)
end

-- get necessary information from the robot
-- related infomaiont: 1. robot type and name
-- 2. the number of joints
-- 3. the joint limit
-- 4. the position limit
function robotInfo()
    local robotInfo={}
    local jointLimitLows={}
    local jointLimitRanges={}
    
    -- get robot name
    robotName=sim.getObjectAlias(simBase,-1)
    robotInfo.robotName=robotName
    
    -- get joint amount and limits
    for i=1,#jointHandles,1 do
        local cyclic,interv=sim.getJointInterval(jointHandles[i]) -- judge if the joint is cyclic
        if cyclic then
            jointLimitLows[i]=-180*math.pi/180
            jointLimitRanges[i]=360*math.pi/180
        else
            jointLimitLows[i]=interv[1]
            jointLimitRanges[i]=interv[2]
        end
    end
    robotInfo.jointAmount=#jointHandles
    robotInfo.jointLimitLows=jointLimitLows
    robotInfo.jointLimitHighs=jointLimitRanges
    
    -- get position limit
    -- 21.01.2023 just according to object height to set limits
    local model_x=sim.getObjectFloatParam(simBase, sim.objfloatparam_modelbbox_max_x)
    local model_y=sim.getObjectFloatParam(simBase, sim.objfloatparam_modelbbox_max_y)
    local model_z=sim.getObjectFloatParam(simBase, sim.objfloatparam_modelbbox_max_z)
    
    robotInfo.positionLimits=math.max(model_x,model_y,model_z)
    
    return robotInfo
end

function coroutineMain()
    local targetPos1={90*math.pi/180,90*math.pi/180,-90*math.pi/180,90*math.pi/180,90*math.pi/180,90*math.pi/180}
    --moveToConfig(jointHandles,maxVel,maxAccel,maxJerk,targetPos1)
    --moveTojoint(targetPos1)
    local info=robotInfo()
    --print(info)
    
    --moveToPosition({0.2,-0.1,0.4})
    local targetPos2={-90*math.pi/180,45*math.pi/180,90*math.pi/180,135*math.pi/180,90*math.pi/180,90*math.pi/180}
    --moveToConfig(jointHandles,maxVel,maxAccel,maxJerk,targetPos2)

    local targetPos3={0,0,0,0,0,0}
    --moveToConfig(jointHandles,maxVel,maxAccel,maxJerk,targetPos3)
end