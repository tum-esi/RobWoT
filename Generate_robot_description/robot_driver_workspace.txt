function sysCall_init()
    corout=coroutine.create(coroutineMain)
    a=2 -- this is for compute working space
    
    -- initialize the dummy point for IK
    local tipHandle = sim.createDummy(0.01)
    local targetHandle = sim.createDummy(0.01)
    -- dummy point rename
    sim.setObjectAlias(tipHandle, "tip")
    sim.setObjectAlias(targetHandle, "target")
    -- set the dummy point position
    simBase=sim.getObject('.')
    objectHandlesall = sim.getObjectsInTree(simBase,sim.handle_all,0)
    --print(sim.getObjectAlias(objectHandlesall[#objectHandlesall],-1))
    -- endEffector is not a idel position, modify it later
    endEffectorpos = sim.getObjectPosition(objectHandlesall[#objectHandlesall], sim.handle_world)
    sim.setObjectPosition(tipHandle, sim.handle_world, endEffectorpos)
    sim.setObjectPosition(targetHandle, sim.handle_world, endEffectorpos)
    -- set dummy point to the parent object
    sim.setObjectParent(tipHandle,objectHandlesall[#objectHandlesall],true)
    sim.setObjectParent(targetHandle,simBase,true)
    
    
    -- get joint Handles
    jointHandles = sim.getObjectsInTree(simBase,sim.object_joint_type,0)
    
    -- prepare handles for the IK calculation
    simBase=sim.getObject('.')
    simTip=sim.getObject('./tip')
    simTarget=sim.getObject('./target')
    
    simJoints=jointHandles
    -- Prepare an ik group, using the convenience function 'simIK.addIkElementFromScene':
    ikEnv=simIK.createEnvironment()
    ikGroup=simIK.createIkGroup(ikEnv)
    -- simIK.method_damped_least_squares better 2
    -- simIK.method_undamped_pseudo_inverse terrible 4
    -- simIK.method_jacobian_transpose best  1
    -- simIK.method_pseudo_inverse middle 3
    simIK.setIkGroupCalculation(ikEnv,ikGroup,simIK.method_jacobian_transpose,0.05,180)
    local ikElement=simIK.addIkElementFromScene(ikEnv,ikGroup,simBase,simTip,simTarget,simIK.constraint_pose)
    simIK.setIkElementPrecision(ikEnv,ikGroup,ikElement,{0.0005,0.001*math.pi/180})
    
    -- set basic parameters for vel, accel, jerk for the moveTojoint
    local vel=180
    local accel=40
    local jerk=80
    default_maxVel={vel*math.pi/180,vel*math.pi/180,vel*math.pi/180,vel*math.pi/180,vel*math.pi/180,vel*math.pi/180}
    default_maxAccel={accel*math.pi/180,accel*math.pi/180,accel*math.pi/180,accel*math.pi/180,accel*math.pi/180,accel*math.pi/180}
    default_maxJerk={jerk*math.pi/180,jerk*math.pi/180,jerk*math.pi/180,jerk*math.pi/180,jerk*math.pi/180,jerk*math.pi/180}
    
    maxVel={}
    maxAccel={}
    maxJerk={}
    initialJointPositions={} -- also record the inital joint position
    for i=1,#jointHandles,1 do
        maxVel[i]=default_maxVel[i]
        maxAccel[i]=default_maxAccel[i]
        maxJerk[i]=default_maxJerk[i]
        initialJointPositions[i]=sim.getJointPosition(jointHandles[i])
    end
    
end

-- create working space
doCalculation=function()
    local divisions=5 -- the divisions used for each joint. The total nb of pts becomes (divisions+1)^7
    local checkCollision=true
    local usePointCloud=true -- if false, 3D spheres will be used
    local extractConvexHull=true
    local generateRandom=true -- Use random configurations instead of joint divisions
    local randomSteps=80000 -- Number of random configs to test
    
    local jointHandles={}
    local jointLimitLows={}
    local jointLimitRanges={}
    local initialJointPositions={}
    
    for i=1,6,1 do
        jointHandles[i]=sim.getObject('./joint',{index=i-1})
        local cyclic,interv=sim.getJointInterval(jointHandles[i]) -- judge if the joint is cyclic
        if cyclic then
            jointLimitLows[i]=-180*math.pi/180
            jointLimitRanges[i]=360*math.pi/180
        else
            jointLimitLows[i]=interv[1]
            jointLimitRanges[i]=interv[2]
        end
        initialJointPositions[i]=sim.getJointPosition(jointHandles[i])
    end
    
    local tip=sim.getObject('./tip')
    local base=sim.getObject('.')
    local robotCollection=sim.createCollection(0)
    sim.addItemToCollection(robotCollection,sim.handle_tree,base,0)
    local points={}
    
    if not usePointCloud then
        pointContainer=sim.addDrawingObject(sim.drawing_spherepts,0.01,0.01,base,99999,{1,1,1})
    end
    
    if generateRandom then
        for cnt=1,randomSteps,1 do
            local p1=jointLimitLows[1]+math.random()*jointLimitRanges[1]
            sim.setJointPosition(jointHandles[1],p1)
            local p2=jointLimitLows[2]+math.random()*jointLimitRanges[2]
            sim.setJointPosition(jointHandles[2],p2)
            local p3=jointLimitLows[3]+math.random()*jointLimitRanges[3]
            sim.setJointPosition(jointHandles[3],p3)
            local p4=jointLimitLows[4]+math.random()*jointLimitRanges[4]
            sim.setJointPosition(jointHandles[4],p4)
            local p5=jointLimitLows[5]+math.random()*jointLimitRanges[5]
            sim.setJointPosition(jointHandles[5],p5)
            local p6=jointLimitLows[6]+math.random()*jointLimitRanges[6]
            sim.setJointPosition(jointHandles[6],p6)

            local colliding=false
            local matrix=sim.getObjectMatrix(tip,sim.handle_world)
            
            if checkCollision then
                if sim.checkCollision(robotCollection,sim.handle_all)~=0 then
                    colliding=true
                end
            end
            
            if not colliding then
                points[#points+1]=matrix[4]
                points[#points+1]=matrix[8]
                points[#points+1]=matrix[12]
                if not usePointCloud then
                    sim.addDrawingObjectItem(pointContainer,{matrix[4],matrix[8],matrix[12]})
                end
            end
            
        end
    
    else
        for i1=1,divisions+1,1 do
            local p1=jointLimitLows[1]+(i1-1)*jointLimitRanges[1]/divisions
            sim.setJointPosition(jointHandles[1],p1)
            for i2=1,divisions+1,1 do
                local p2=jointLimitLows[2]+(i2-1)*jointLimitRanges[2]/divisions
                sim.setJointPosition(jointHandles[2],p2)
                for i3=1,divisions+1,1 do
                    local p3=jointLimitLows[3]+(i3-1)*jointLimitRanges[3]/divisions
                    sim.setJointPosition(jointHandles[3],p3)
                    for i4=1,divisions+1,1 do
                        local p4=jointLimitLows[4]+(i4-1)*jointLimitRanges[4]/divisions
                        sim.setJointPosition(jointHandles[4],p4)
                        for i5=1,divisions+1,1 do
                            local p5=jointLimitLows[5]+(i5-1)*jointLimitRanges[5]/divisions
                            sim.setJointPosition(jointHandles[5],p5)
                            for i6=1,divisions+1,1 do
                                local p6=jointLimitLows[6]+(i6-1)*jointLimitRanges[6]/divisions
                                sim.setJointPosition(jointHandles[6],p6)

                                local colliding=false
                                local matrix=sim.getObjectMatrix(tip,sim.handle_world)
                                -- local pos=sim.getObjectPosition(tip,sim.handle_world)
                                if checkCollision then
                                    if sim.checkCollision(robotCollection,sim.handle_all)~=0 then
                                        colliding=true
                                    end
                                end
                                if not colliding then
                                    points[#points+1]=matrix[4]
                                    points[#points+1]=matrix[8]
                                    points[#points+1]=matrix[12]
                                    if not usePointCloud then
                                        sim.addDrawingObjectItem(pointContainer,{matrix[4],matrix[8],matrix[12]})
                                    end
                                end
                                
                            end
                        end
                    end
                end
            end
        end
    
    end
    
    for i=1,6,1 do
        sim.setJointPosition(jointHandles[i],initialJointPositions[i])
    end
    
    --print(points)
    if usePointCloud then
        local ptcld=sim.createPointCloud(0.05,1,0,2)
        sim.insertPointsIntoPointCloud(ptcld,0,points)
    end
    
    if extractConvexHull then
        local vertices,indices=sim.getQHull(points)
        local shape=sim.createMeshShape(3,0,vertices,indices)
        sim.reorientShapeBoundingBox(shape,-1)
        sim.setShapeColor(shape,nil,0,{1,0,1})
        sim.setShapeColor(shape,nil,4,{0.2})
        local a,b,c = {}
        a,b,c = sim.getShapeMesh(shape)
        
        sim.setObjectParent(shape,simBase,true)
        
        -- export the shape as stl file to local computer
        local robotName="robot_shape.stl"
        --local aa,bb,cc =simAssimp.getExportFormat(4) -- only in this way return stl
        --print(cc)
        local scenePath=sim.getStringParam(sim.stringparam_scene_path_and_name)
        --print(scenePath)
        local sceneName=sim.getStringParam(sim.stringparam_scene_name)
        --print(sceneName)
        
        local filePath=string.gsub(scenePath,sceneName,robotName)
        print(filePath)
        
        --sim.stopSimulation()
        
        simAssimp.exportShapes({shape},filePath,"stl",1)
        --sim.exportMesh(4,"d:\\robot_shape.stl",0,1,a,b)
        
    end

end

function sysCall_actuation()
    if coroutine.status(corout)~='dead' then
        local ok,errorMsg=coroutine.resume(corout)
        if errorMsg then
            error(debug.traceback(corout,errorMsg),2)
        end
    end
    -- for function doCalculation
    a=a+1
    if a==2 then
        doCalculation()
    end
end

function generateWorkingspace()
    --a = 0
    doCalculation()
        
    return "success"
end

-- This is a threaded script, and is just an example!
function moveToPoseCallback(pose,velocity,accel,auxData)
    sim.setObjectPose(auxData.target,sim.handle_world,pose)
    simIK.applyIkEnvironmentToScene(auxData.ikEnv,auxData.ikGroup)
end

function moveToPose_viaIK(maxVelocity,maxAcceleration,maxJerk,targetPose,auxData)
    local currentPose=sim.getObjectPose(auxData.tip,sim.handle_world)
    return sim.moveToPose(-1,currentPose,maxVelocity,maxAcceleration,maxJerk,targetPose,moveToPoseCallback,auxData,nil)
end

function movCallback(config,vel,accel,handles)
    for i=1,#handles,1 do
        if sim.isDynamicallyEnabled(handles[i]) then
            sim.setJointTargetPosition(handles[i],config[i])
        else    
            sim.setJointPosition(handles[i],config[i])
        end
    end
end

function moveToConfig(handles,maxVel,maxAccel,maxJerk,targetConf)
    local currentConf={}
    for i=1,#handles,1 do
        currentConf[i]=sim.getJointPosition(handles[i])
    end
    sim.moveToConfig(-1,currentConf,nil,nil,maxVel,maxAccel,maxJerk,targetConf,nil,movCallback,handles)
end

function moveTojoint(position)
    moveToConfig(jointHandles,maxVel,maxAccel,maxJerk,position)
end

function getJointposition()
    local curJointpos={}
    for i=1,#jointHandles,1 do
        curJointpos[i]=sim.getJointPosition(jointHandles[i])
    end
    
    return curJointpos
end

function moveToinitialPosition()
    moveTojoint(initialJointPositions)
end

function moveToPosition(targetPosition)
    -- convert the targetPosition to targetPose
    local targetDummy = sim.createDummy(0.01)
    sim.setObjectPosition(targetDummy,sim.getObject('.'), targetPosition)
    
    local targetPose = sim.getObjectPose(targetDummy,sim.handle_world)
    sim.removeObject(targetDummy)

    -- IK movement data:
    local maxIkVel={0.45,0.45,0.45,4.5} -- vx,vy,vz in m/s, Vtheta is rad/s
    local maxIkAccel={0.13,0.13,0.13,1.24} -- ax,ay,az in m/s^2, Atheta is rad/s^2
    local maxIkJerk={0.1,0.1,0.1,0.2} -- is ignored (i.e. infinite) with RML type 2
    
    local data={}
    data.ikEnv=ikEnv
    data.ikGroup=ikGroup
    data.tip=simTip
    data.target=simTarget
    data.joints=simJoints

    moveToPose_viaIK(maxIkVel,maxIkAccel,maxIkJerk,targetPose,data)
end

-- get necessary information from the robot
-- related infomaiont: 1. robot type and name
-- 2. the number of joints
-- 3. the joint limit
-- 4. the position limit
function robotInfo(robotType)
    local robotInfo={}
    local jointLimitLows={}
    local jointLimitRanges={}
    
    -- get robot name
    --robotName=sim.getObjectAlias(simBase,-1)
    robotName=robotType
    robotInfo.robotName=robotName
    
    -- get joint amount and limits
    for i=1,#jointHandles,1 do
        local cyclic,interv=sim.getJointInterval(jointHandles[i]) -- judge if the joint is cyclic
        if cyclic then
            jointLimitLows[i]=-180*math.pi/180
            jointLimitRanges[i]=360*math.pi/180
        else
            jointLimitLows[i]=interv[1]
            jointLimitRanges[i]=interv[2]
        end
    end
    robotInfo.jointAmount=#jointHandles
    robotInfo.jointLimitLows=jointLimitLows
    robotInfo.jointLimitHighs=jointLimitRanges
    
    -- get position limit
    -- 21.01.2023 just according to object height to set limits
    local model_x=sim.getObjectFloatParam(simBase, sim.objfloatparam_modelbbox_max_x)
    local model_y=sim.getObjectFloatParam(simBase, sim.objfloatparam_modelbbox_max_y)
    local model_z=sim.getObjectFloatParam(simBase, sim.objfloatparam_modelbbox_max_z)
    
    robotInfo.positionLimits=math.max(model_x,model_y,model_z)
    
    return robotInfo
end

function coroutineMain()
    local targetPos1={90*math.pi/180,90*math.pi/180,-90*math.pi/180,90*math.pi/180,90*math.pi/180,90*math.pi/180}
    --moveToConfig(jointHandles,maxVel,maxAccel,maxJerk,targetPos1)
    --moveTojoint(targetPos1)
    local info=robotInfo()
    --print(info)
    --generateWorkingspace(0)
    
    --moveToPosition({0.2,-0.1,0.4})
    local targetPos2={-90*math.pi/180,45*math.pi/180,90*math.pi/180,135*math.pi/180,90*math.pi/180,90*math.pi/180}
    --moveToConfig(jointHandles,maxVel,maxAccel,maxJerk,targetPos2)

    local targetPos3={0,0,0,0,0,0}
    --moveToConfig(jointHandles,maxVel,maxAccel,maxJerk,targetPos3)
end